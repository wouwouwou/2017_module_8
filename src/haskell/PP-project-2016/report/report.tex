%------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%------------------------------------------------

\documentclass[twoside]{report}

\usepackage{graphicx}

\usepackage{minted}

\usepackage{amsmath,amssymb,amsthm} % Mathematical Symbols, styles, etc

\usepackage[sc]{mathpazo} % Use the Palatino font
% Output encoding
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
% Input encoding
\usepackage[utf8]{inputenc} % UTF-8 character encoding stuff
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{float} % Required for tables and figures in the multi-column environment - they need to be placed in specific locations with the [H] (e.g. \begin{table}[H])
\usepackage{hyperref} % For hyperlinks in the PDF
\newcommand*{\fullref}[1]{\hyperref[{#1}]{\ref*{#1} (\nameref*{#1})}}
\newcommand*{\fullautoref}[1]{\hyperref[{#1}]{\autoref*{#1} (\nameref*{#1})}}

\usepackage{pdflscape} % For landscape pages

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text
\usepackage{paralist} % Used for the compactitem environment which makes bullet points with less space between them

\usepackage{titlesec} % Allows customization of titles
%\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
%\renewcommand\thesubsection{\Roman{subsection}} % Roman numerals for subsections
%\titleformat{\section}[block]{\large\scshape}{\thesection.}{1em}{} % Change the look of the section titles
%\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the subsection titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{M.F. Verkleij, T. Kerkhoven: \shorttitle} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

% Appendices
\usepackage[toc,page]{appendix} % appendix

% Additional column type
\usepackage{array}
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}

% Indentation of list
\usepackage{changepage}
\newenvironment{mycompactdesc}{\begin{adjustwidth}{0.53cm}{}\begin{compactdesc}}{\end{compactdesc}\end{adjustwidth}}

%------------------------------------------------
%	TITLE SECTION
%------------------------------------------------

\newcommand{\articletitle}{Programming Paradigms Final Project: Building a Compiler in Haskell for the Sprockell}
\newcommand{\shorttitle}{PP Final Project}

\title{\vspace{-15mm}\fontsize{24pt}{10pt}\selectfont\textbf{\articletitle}} % Article title

\author{
\large
\textsc{Group 26}\\[-0.75mm]
\textsc{Martijn Verkleij \& Tim Kerkhoven}\\[2mm] % Your name
\normalsize University of Twente \\ % Your institution
\normalsize \href{mailto:m.f.verkleij@student.utwente.nl}{m.f.verkleij@student.utwente.nl},
\href{mailto:t.kerkhoven@student.utwente.nl}{t.kerkhoven@student.utwente.nl}\\% Your email addresses
\normalsize s1466895 s1375253
}

\date{\today}

%------------------------------------------------

\begin{document}

\thispagestyle{empty}
\maketitle % Insert title


%------------------------------------------------
%	ARTICLE CONTENTS
%------------------------------------------------

%------------------------------------------------
\tableofcontents


%------------------------------------------------
\chapter{Introduction}
\label{introduction}
In the Programming Paradigms course, the final project is a combination of compiler construction, functional programming, and concurrent programming. It required the participants to build a compiler for a self-defined language to SprIL. The language had to support features, including basic concurrency.

The language group 26 designed for this project is called Simple Haskell Language (SHL), with file extension \emph{.shl}. It supports all the required features, as well as some additional features. These additional features include: procedures, and call-by-reference. The entire compiler runs on uses Haskell, both the code-generation and front end. The Sprockell was slightly extended as well.


%------------------------------------------------
\chapter{Summary}
\label{summary}
This chapter will give a summary of the features of SHL. 
\paragraph{Data types} SHL supports two types: integers and booleans. 
\paragraph{Simple expressions and variables} SHL supports denotations for primitive values of types as well as operations for (in)equality for values of types. SHL is strongly typed and all variables are initialised upon declaration. It also supports scoping with variable shadowing. The following expressions are supported:
\begin{compactitem}
	\item Parentheses
	\item Assignment
	\item Operation (with ==, !=, <>, \&\&, ||, <=, >=, <, >, +, -, *)
	\item Unary operation (with !, -)
	\item Variable
	\item Integer value
	\item Boolean value
\end{compactitem}
\paragraph{Basic statements} SHL supports the following statements: 
\begin{compactitem}
	\item Block
	\item Declaration
	\item If 
	\item While
	\item Call
	\item Fork 
	\item Join
	\item Print
	\item Expression
\end{compactitem}
\paragraph{Concurrency} SHL supports global variables, fork and join statements to implement concurrency.
\paragraph{Procedures} SHL supports basic procedures with call-by-reference.


%------------------------------------------------
\chapter{Problems \& Solutions}
\label{problems_and_solutions}
This chapter is a short discussion of some of the problems encountered during the project and their solutions.

\section{Changing the Types}
During the process of building the type checker and code generation, which was done in parallel, at certain times a change to the AST or Grammar was required. This resulted in a lot of trying to find every instance which had to be changed, and finding unused code during the final day of the project.

\section{Time}
If only the schedule made at the beginning of every project works out and no unexpected problems arise, this would not be a problem. Reality, unfortunately, has not been that kind. Many unscheduled delays and problems arose to delay the schedule more than expected. The solution for this is working evenings and parts of the night on the final days.

\section{Concurrency}
The problem with concurrency was mostly that the direction it was being taken changed several times. The addition of explicit locks was discussed and partly executed, then eventually reverted. The way global variables were handled was changed multiple times, as well as some other things. Until time was taken to really think it through, and determine what it should and should not do, and what it could and could not do. 

\section{Call-by-reference}
Call-by-reference became a bit of a problem because of some design flaws. Because of the way our ARs work and the visibility of certain aspects of variables when passed as arguments, changes had to be made to the old design to what it currently is (see \fullref{def:call-by-reference}). These changes caused quite some work during their implementation.

\section{Code Generation}
During code generation, two big types of problems arose, of which the first one was offset management. SprIL does not know labels as ILOC does, and since our code was generated with a tree, many things as procedure addresses, retrun addresses and the like were not known on the first pass. Furthermore, fixing bugs in logic often messes up offsets in loops, creating their own set of incomprehensible issues.

The second issue was memory management. Not knowing beforehand what you need in an AR does not help when debugging issues with values being read as addresses and the other way around. But by far the most annoying issue I've had was a bug in Sprockell where writes to out-of-bounds addresses to global memory were not protected. Instead, they extended the list, resulting in all variables moving one step. Good luck debugging when one cannot trust the integrity of memory.


%------------------------------------------------
\chapter{Sprockell Extensions}
\label{sprockell_extensions}

\section{Shared Memory Bug}
\label{shared_memory_bug}
A bug in shared memory has been resolved. Whenever a value was written to shared memory to an out of bounds index, shared memory would be extended with that value. The list would be longer by one with the new value at either the first or last position in the list, depending on whether the index was too low or too high.

The extension causes an error to be thrown instead. This allows for easier debugging of code generation.

\section{PrintOut Instruction}
\label{printout_instruction}
A print instruction, \texttt{PrintOut reg}, was added to print registers to stdout. The instruction uses \texttt{trace} from the package \texttt{Debug.Trace} to do this.

\section{ComputeI Instruction}
\label{computei_instruction}
A compute with immediate value, \texttt{ComputeI operator reg value reg}. This instruction takes a register and a value to do a computation with the operator, which is then written to the second register. It is mostly used to calculate ARP offsets. 

This instruction was inspired by the \emph{iloc} instructions using an immediate value (eg. \texttt{AddI, SubI}.

\section{Incr4 \& Decr4}
\label{incr4_and_decr4}
Two \texttt{Operator}s were added to the alu operators: Incr4 and Decr4. They were originally added to more easily do the steps of four to calculate offsets, before \texttt{ComputeI} was added. They are currently unused.


%------------------------------------------------
\chapter{Detailed Language Description}
\label{detailed_language_description}
This chapter will describe every feature of SHL in detail: providing a basic description; information on the syntax with at least one example; usage information along with restrictions; a description of its effects and execution; and some general information on the generated code.

%\section{General/collection}
%\subsection{Feature}
%\subsubsection*{Syntax}
%\subsubsection*{Usage}
%\subsubsection*{Semantics}
%\subsubsection*{Code Generation}


\subsection{Program}
\label{def:program}
\subsubsection*{Syntax}
\texttt{[GLOBAL]\ldots [PROCEDURE]\ldots [STATEMENTS]\ldots}\\
\begin{mycompactdesc}
	\item[GLOBAL] Global variable declarations as defined in \fullref{def:global}
	\item[PROCEDURE] Procedures as defined in \fullref{def:procedure}
	\item[STATEMENTS] Statements as defined in \fullref{def:statements}
\end{mycompactdesc}
\paragraph{Example}
\begin{minted}[tabsize=4]{text}
global int number = 5;

procedure eq(int num1, int num2, bool out) {
	if ((num1 == num2)) {
		out = true;
	} else {
		out = false;
	}
}

int otherNumber = 6;
bool out;
eq(number, otherNumber, out);
print(out);
\end{minted}
\subsubsection*{Usage}
All files must follow the program syntax, and may only contain a single program.
\subsubsection*{Semantics}
A program is a collection of code which can be used to create an executable set of instructions. It is the root node of the Abstract Syntax Tree.
\subsubsection*{Code Generation}
Any program is generally built up as follows:
\begin{compactitem}
	\item \textbf{Thread control code}
	\begin{compactitem}
		\item \textbf{Thread Control Loop} \\ All extra threads loop here, waiting to accept fork calls.
		\item \textbf{PreCall forked procedures} \\ Once a sprockell accepts a fork call, it reads the AR from global memory, and starts execution.
		\item \textbf{PostCall forked procedures} \\ Once an auxilary sprockell finishes the procedure, this code handles cleanup.
	\end{compactitem}
	\item \textbf{Procedures \ref{def:procedure}}
	\item \textbf{Global declarations \ref{def:global}}
	\item \textbf{Main code}
	
	\item \textbf{Post-program code} \\ Stops auxilary threads.
\end{compactitem}


\subsection{Global}
\label{def:global}
\subsubsection*{Syntax}
\texttt{global <TYPE> <ID> [= <EXPRESSION>] ;}
\begin{mycompactdesc}
	\item[TYPE] A type as defined in \fullref{def:types}
	\item[ID] A string as defined by \fullref{def:variable}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
global bool flag = true;
global int number;
\end{minted}
\subsubsection*{Usage}
Used to declare global variables and an optional assignment.  The type of the expression must match the type of the global variable.

All global variables MUST be defined at the top of the program, even before procedures.

The id of a global variable is unique in the whole program. No other variable of procedure may use the same id. They can therefore not be shadowed.
\subsubsection*{Semantics}
The global variable declaration reserves a space in shared memory and writes a value to it. All global variables are initialized to the default value (see \fullref{def:integer} and \fullref{def:boolean}) if no value is explicitly assigned.

Global variables are reachable from anywhere below its declaration in the code, in any thread. Beware, however, that the variable can be written to from any thread as well, and using the shared memory is significantly slower than using the local memory.

Globals that are passed as arguments to a procedure have their own intricacies, see \ref{def:call-by-refence} for more information.

\subsubsection*{Code Generation}
All globals are saved in global memory. Writes and reads to globals are done atomically, but assignments are not. This avoids data races, but to ensure atomicity on the whole assignment, one must implement his own mutual exclusion.


\subsection{Procedure}
\label{def:procedure}
\subsubsection*{Syntax}
\texttt{procedure <ID> ( [<TYPE> <VAR>] [, <TYPE> <VAR>]\ldots ) <STATEMENT>...}
\begin{mycompactdesc}
	\item[ID] A string as defined in \fullref{def:variable}
	\item[TYPE] A type as defined in \fullref{def:types}
	\item[VAR] A variable as defined in \fullref{def:variable}
	\item[STATEMENT] A statement as defined in \fullref{def:statements}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
procedure empty() print(0);
procedure other(int num, bool flip) {
	while ((num > 0)) {
		num = --num;
		flip = !flip;
	}
	print(num, flip);
}
\end{minted}
\subsubsection*{Usage}
Used to declare a procedure. Because call-by-reference (see \fullref{def:call-by-reference}) is used, a variable passed as an argument can be used to write resulting values. One could also use the global variables (see \fullref{def:global}), as they are accessible from everywhere.

The id of a procedure is unique in the whole program. No other variable of procedure may use the same id.
\subsubsection*{Semantics}
A procedure is section of code that can be executed from anywhere, using a call or fork statement (see \fullref{def:call} and \fullref{def:fork}) and passing the appropriate number of arguments to it.
\subsubsection*{Code Generation}
Procedure code has the following structure:
\begin{compactitem}
	\item \textbf{PostCall code} \\ Copies all arguments into the local data area for use. 
	\item \textbf{Procedure's statements}
	\item \textbf{PreReturn code} \\ The final result of all arguments is read, and if they are global or local variables, saved to the appropriate location.
\end{compactitem}


\section{Statements}
\label{def:statements}


\subsection{Declaration}
\label{def:declaration}
\subsubsection*{Syntax}
\texttt{<TYPE> <ID> [= <EXPRESSION>] ;}
\begin{mycompactdesc}
	\item[TYPE] A type as defined in \fullref{def:types}
	\item[ID] A string as defined in \fullref{def:variable}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
int number = (1+1);
bool flag;
\end{minted}
\subsubsection*{Usage}
Used to declare local variables and an optional assignment. The type of the expression must match the type of the variable.

The id of a variable is unique in the scope it is defined in. No other variable in that scope may use the same id.
\subsubsection*{Semantics}
The variable declaration writes the value of the variable to the Local Data Area of where it was (most recently) defined. All variables are initialized to the default value (see \fullref{def:integer} and \fullref{def:boolean}) if no value is explicitly assigned.
\subsubsection*{Code Generation}
A declaration evaluates the expression behind it before assigning it to the variable. The variable's value is saved in the appropriate Local Data Area, by following the scopes upward until the right scope is reached, after which it is saved with an offset.

\subsection{If}
\label{def:if}
\subsubsection*{Syntax}
\texttt{if ( <EXPRESSION> ) <STATEMENT> [else <STATEMENT>]}
\begin{mycompactdesc}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
	\item[STATEMENT] A statement as defined in \fullref{def:statements}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
if (flag) {
	// do something
}
if (flag) print(flag); else {
	// do something
}
\end{minted}
\subsubsection*{Usage}
Execute a section of code based on an expression. The type of this expression must be a boolean.
\subsubsection*{Semantics}
If the expression evaluates to \emph{true}, execute the first statement. If it evaluates to \emph{false}, execute the code after the first statement, which can be either the second statement or the code that comes after the if statement.
\subsubsection*{Code Generation}
First the expression will be evaluated, after which a branch jumps to the else block upon a false result, or to the next expression if no else block is present. After the if-block, a jump to after the else block is placed when an else block is present.

\subsection{While}
\label{def:while}
\subsubsection*{Syntax}
\texttt{while ( <EXPRESSION> ) <STATEMENT>}
\begin{mycompactdesc}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
	\item[STATEMENT] A statement as defined in \fullref{def:statements}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
while (flag) {
	// do something
}
\end{minted}
\subsubsection*{Usage}
Execute a section of code while the expression is \emph{true}. The type of this expression must be a boolean.
\subsubsection*{Semantics}
If the expression evaluates to \emph{true}, execute the statement. Repeat this for as long as the expression keeps evaluating to \emph{true}.
\subsubsection*{Code Generation}
As long as the expression is true, the code in the following block will be executed. The expression is re-evaluated after each execution of the block.


\subsection{Fork}
\label{def:fork}
\subsubsection*{Syntax}
\texttt{fork <ID> ( [<EXPRESSION> [, <EXPRESSION>]\ldots] ) ;}
\begin{mycompactdesc}
	\item[ID] A string as defined by \fullref{def:variable}
	\item[EXPRESSION] An expression as defined by \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
fork proc0();
fork proc1(flag);
fork proc2(5, flag = true);
\end{minted}
\subsubsection*{Usage}
Run a procedure, which must have been declared somewhere, on a separate thread. The expression types must match the types defined during the procedure declaration (see \fullref{def:procedure}).
\subsubsection*{Semantics}
Writes the argument to shared memory and tells the thread pool to start parallel execution of the procedure.

Beware, if more procedures are given to the thread pool than there are threads, fork may have to wait for a thread to finish its work before continuing execution. In the case where programs with forks are executed on only one sprockell, it will deadlock.
\subsubsection*{Code Generation}
A fork call must start a procedure in another thread. To accomplish this, the first 30 addresses in global memory are reserved for this purpose. A further few addresses, namely as much as there atre threads, are reserved for an occupation bit. In practise this means that procedures with more than 7 arguments cannot be forked without memory corrupting.

The addresses are reserved as follows:

\begin{compactitem}
	\item \textbf{End flag} \\ Set when the auxilary threads may cease execution. Each auxilary sprockell checks this record before attempting to read an AR from shared memory  
	\item \textbf{Wr flag} \\ Used to set the AR space as occupied by an AR that may be executed. An auxilary threads sets it to 0 when it has read the AR.
	\item \textbf{Rd flag} \\ Read-protects the AR as it is being written, and to exclude other sprockells from handling the request.
	\item \textbf{Jump index} \\ line number of the procedure to execute.
	\item \textbf{Argument count} \\ Number of arguments that follow.
	\item \textbf{Arguments...}
	\begin{compactitem}
		\item \textbf{Value}
		\item \textbf{Local address} \\ The address to write the result back to, if the argument has one. For example, an expression has none.
		\item \textbf{Global address} \\  Idem.
	\end{compactitem}
\end{compactitem}




\subsection{Join}
\label{def:join}
\subsubsection*{Syntax}
\texttt{join ;}
\paragraph{Example}
\begin{minted}[tabsize=4]{text}
join;
\end{minted}
\subsubsection*{Usage}
Ensures all auxilary threads have finished execution before continuing. 
\subsubsection*{Semantics}
Blocks execution of the main thread until all other threads have finished their work. May only be called in code that is not executed in auxilary threads, for example by calling a procedure with fork that contains a join statement.
\subsubsection*{Code Generation}
A join statement iterates over the occupation bits of all auxilary threads. Only if they are all zero, this statement may end. It will therefore throw an error when called from an auxilary thread, as can happen when used in a procedure.


\subsection{Call}
\label{def:call}
\subsubsection*{Syntax}
\texttt{<ID> ( [<EXPRESSION> [, <EXPRESSION>]\ldots] ) ;}
\begin{mycompactdesc}
	\item[ID] A string as defined by \fullref{def:variable}
	\item[EXPRESSION] An expression as defined by \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
proc0();
proc1(flag);
proc2(5, flag = true);
\end{minted}
\subsubsection*{Usage}
Execute the called procedure sequentially, which must have been declared. The expressions must have the same types as the procedure's as defined in its declaration (see \fullref{def:procedure})
\subsubsection*{Semantics}
Go to the procedure code and execute the procedure with the expressions, then return to the call.
\subsubsection*{Code Generation}
Calls a procedure sequentially. Any separate variables that are given as an argument are handled call-by-reference. Sets up the AR before jumping to the procedure. 


\subsection{Expression}
\label{def:expression_statement}
\subsubsection*{Syntax}
\texttt{<EXPRESSION> ;}
\begin{mycompactdesc}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
a = (5 + (--6));
true;
-++++++++++a;
\end{minted}
\subsubsection*{Usage}
Allows expressions to be executed as statements, mostly for the purpose of enabling an assignment (see \fullref{def:assignment}) as a statement, since an assignment is an expression.
\subsubsection*{Semantics}
Execute the expression, this generally has no effects, except for an assignment.
\subsubsection*{Code Generation}
As expressions have a result on stack, one must pop this value if the expression is defined as a statement. Otherwise the stack would fill up.


\subsection{Block}
\label{def:block}
\subsubsection*{Syntax}
\texttt{\{ [STATEMENT]\ldots \}}
\begin{mycompactdesc}
	\item[STATEMENT] A statement as defined in \fullref{def:statements}
\end{mycompactdesc}
\paragraph{Example}
\begin{minted}[tabsize=4]{text}
{
	int i = 0;
	{
		i = ++i;
		{
			int i = 5;
		}
		print((i == 1));
	}
	print((i == 1));
}
\end{minted}
\subsubsection*{Usage}
A block is a single statement that contains zero or more statements. It is mostly used within procedures and statements to executes more than one statement.
\subsubsection*{Semantics}
A block opens a new scope, then executes the code within. When exiting a block, the scope is closed.
\subsubsection*{Code Generation}
As any block opens a new scope, a new mini-AR is created for each scope. It only contains a pointer to it's parent's AR and all variables declared in this scope in a Local Data Area.


\subsection{Print}
\label{def:print}
\subsubsection*{Syntax}
\texttt{print ( <EXPRESSION> [, <EXPRESSION>]\ldots ) ;}
\begin{mycompactdesc}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
print(a);
print(true, 5, 1983);
print(a = ++a, ((11 - 2) * a));
\end{minted}
\subsubsection*{Usage}
Prints values of evaluated expressions to the console.
\subsubsection*{Semantics}
Evaluates the expressions and prints the values as they appear in memory, meaning a boolean is represented as either a zero (\emph{false}) or a one (\emph{true}).
\subsubsection*{Code Generation}
As SprIL does not have a print instruction, a new one was created and added to the Sprockell source code. See also chapter \ref{sprockell_extensions}. This statement simply evaluates all expressions in its arguments and prints them one per line.


\section{Expressions}
\label{def:expressions}


\subsection{Parentheses}
\label{def:parentheses}
\subsubsection*{Syntax}
\texttt{( <EXPRESSION> )}
\begin{mycompactdesc}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Example}
\begin{minted}[tabsize=4]{text}
a = -(-(----a); // the same as: a = (-1) * (-1) * (a - 2);
\end{minted}
\subsubsection*{Usage}
Parentheses are used to enforce which operator is used (see the example above). It can also be used to enforce the order in which an expression is evaluated, but since this already explicitly happens (see \fullref{def:operation}) it should not be necessary to use a parentheses expression for it.
\subsubsection*{Semantics}
Everything between the parentheses is evaluated and the value is returned as the result of this expression.
\subsubsection*{Code Generation}
Required around any binary expression and optional around unary expressions to, as in the example, differentiate between the negation and decrement operator. The result of the inner expression is pushed to stack.


\subsection{Assignment}
\label{def:assignment}
\subsubsection*{Syntax}
\texttt{<ID> = <EXPRESSION>}
\begin{mycompactdesc}
	\item[ID] A string as defined in \fullref{def:variable}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
a = 5;
b = (c <> (d && e));
\end{minted}
\subsubsection*{Usage}
Used to assign a value, in the form of an expression, to a variable. The variable must have been declared beforehand, and may be either global or local.

The type of the expression must match the type of the variable.
\subsubsection*{Semantics}
Assignment evaluates the expression and writes it to the address of the variable.
\subsubsection*{Code Generation}
First, the expression will be evaluated. The result is assigned to the variable, may it be in local or global memory. These are resolved by AR traversal and lookup in a static table respectively. The result is pushed to stack.


\subsection{Variable}
\label{def:variable}
\subsubsection*{Syntax}
\texttt{<ID>}
\begin{mycompactdesc}
	\item[ID] A string, starting with a letter, which may use any alphanumerical character in addition to the following characters: \emph{\~{}`'"@\#\$\textbackslash.?:\_{}}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
a
a@__b"42"\#1337'
\end{minted}
\subsubsection*{Usage}
A variable must be declared (see \fullref{def:declaration}) before use. It has a type which is determined upon declaration.
\subsubsection*{Semantics}
Evaluation of a variable returns its value.
\subsubsection*{Code Generation}
The variable's value is looked up in the AR stack or loaded from global memory and pushed to stack.


\subsection{Integer}
\label{def:integer}
\subsubsection*{Syntax}
\texttt{<INTEGER>}
\begin{mycompactdesc}
	\item[INTEGER] An integer string
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
42
1337
0000004201337
\end{minted}
\subsubsection*{Usage}
Takes the value of the integer, removes leading zeros.
\subsubsection*{Semantics}
Upon evaluation it returns its integer value.
\subsubsection*{Code Generation}
Its value is pushed to stack.


\subsection{Boolean}
\label{def:boolean}
\subsubsection*{Syntax}
\texttt{<BOOLEAN>}
\begin{mycompactdesc}
	\item[BOOLEAN] Where a boolean is either "\texttt{true}" or "\texttt{false}"
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
true
false
\end{minted}
\subsubsection*{Usage}
Takes the value of the boolean (either one or zero) and returns it.
\subsubsection*{Semantics}
Upon evaluation, return the corresponding binary representation of the boolean, where \emph{false} equals zero and \emph{true} equals one.
\subsubsection*{Code Generation}
Its value is pushed to stack.


\subsection{Operation}
\label{def:operation}
\subsubsection*{Syntax}
\texttt{( <EXPRESSION> <OPERATOR> <EXPRESSION> )}
\begin{mycompactdesc}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
	\item[OPERATOR] One of the following operators: \texttt{==, !=, \&\&, ||, <>, <=, >=, <, >, +, -, *} (see \fullref{def:operators})
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
(true <> b)
((a + b) == (c + d))
\end{minted}
\subsubsection*{Usage}
Apply operator on two expressions. Both expressions must be of the same type, which must also match one of the types supported by the operator.
\subsubsection*{Semantics}
After both expressions have been evaluated, the operation is evaluated and its result will be returned.
\subsubsection*{Code Generation}
It's left- and right hand side are evaluated, and its results are used as arguments to the operation. The result of the operation is pushed to stack.


\subsection{Unary Operation}
\label{def:unary_operation}
\subsubsection*{Syntax}
\texttt{<OPERATOR> <EXPRESSION>}
\begin{mycompactdesc}
	\item[OPERATOR] One of the following operators: \texttt{--, ++, -, !} (see \fullref{def:operators})
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
!b
-(--a)
---a // is the same as: --(-a)
\end{minted}
\subsubsection*{Usage}
Apply operator on the expression. The expression type must match one of the types supported by the operator.
\subsubsection*{Semantics}
After the expression has been evaluated, the operation is evaluated and its result will be returned.
\subsubsection*{Code Generation}
It's right hand side is evaluated, fed to the operator and its result is pushed to stack.


\section{Other Features}
\label{def:other_features}


\subsection{Types}
\label{def:types}
\subsubsection*{Syntax}
\texttt{<TYPE>}
\begin{mycompactdesc}
	\item[TYPE] Either \texttt{int} or \texttt{bool}
\end{mycompactdesc}


\subsection{Operators}
\label{def:operators}
\subsubsection*{Syntax}
\texttt{<OPERATOR>}
\begin{mycompactdesc}
	\item[OPERATOR] One of the following: \texttt{==, !=, \&\&, ||, <>, <=, >=, <, >, +, -, *, --, ++, !}
\end{mycompactdesc}
\subsubsection*{Usage}
\begin{mycompactdesc}
	\item[OPERATOR] Operation: \texttt{supported types} $\rightarrow$ \texttt{return type}
	\item[==] equals: \texttt{int, bool} $\rightarrow$ \texttt{bool}
	\item[!=] not equals: \texttt{int, bool} $\rightarrow$ \texttt{bool}
	\item[\&\&] and: \texttt{bool} $\rightarrow$ \texttt{bool}
	\item[||] or: \texttt{bool} $\rightarrow$ \texttt{bool}
	\item[<>] xor: \texttt{bool} $\rightarrow$ \texttt{bool}
	\item[<=] lesser than or equals: \texttt{int} $\rightarrow$ \texttt{bool}
	\item[>=] greater than or equals: \texttt{int} $\rightarrow$ \texttt{bool}
	\item[<] lesser than: \texttt{int} $\rightarrow$ \texttt{bool}
	\item[>] greater than: \texttt{int} $\rightarrow$ \texttt{bool}
	\item[+] add: \texttt{int} $\rightarrow$ \texttt{int}
	\item[-] subtract: \texttt{int} $\rightarrow$ \texttt{int}
	\item[*] multiply: \texttt{int} $\rightarrow$ \texttt{int}
	\item[--] decrement: \texttt{int} $\rightarrow$ \texttt{int}
	\item[++] increment: \texttt{int} $\rightarrow$ \texttt{int}
	\item[!] not: \texttt{bool} $\rightarrow$ \texttt{bool}
\end{mycompactdesc}
Beware that using decrement and increment on a variable does not assign the new value to the variable as some other languages might do.


\subsection{Call-by-reference}
\label{def:call-by-reference}
SHL uses call-by-reference on calls to procedures. This is almost essential to make procedures useful, as the only other option to communicate values between a procedure and its caller would be through global memory. 

It is implemented by passing an optional return address in shared and local memory to write the result back to after the procedure is complete. In theory an argument could be written to both at the same time, as a memory slot is used for each (and makes them distinguishable). These are used to write the results back to their memory locations before returning to the caller.


To make use of it, pass any variable as a naked argument to a call to any procedure in the program. Expressions like \texttt{(i+3)} or \texttt{i = 12} do NOT work, as the argument will only be seen as an expression and will therefore not have a memory location associated with it. Keep in mind that any global variables passed as an argument will be written to global memory upon completion of the procedure. This does not influence any assignment inside the procedure, these are still done as they are evaluated.


\subsection{Error Handling}
\label{def:error_handling}
The SHL compiler does not support proper exception handling, but does throw errors of varying usefulness. During the tokenization phase, the only error thrown is an illegal character error.

During the parsing phase, the only error which might be thrown is a token list not fully parsed error, indicating the grammar cannot parse the token list.

The checker phase thrown different kinds of errors, all related to context constraints, they generally indicate the function which throws the error as well as printing some of the responsible data.

The code generation and runtime phases thrown the following kinds of errors:

Upon code generation, an error is thrown when a user attempts to compile code with a fork statement with the intention of using only one thread.

During runtime, when a join statement is executed by a thread other than the main thread, it prints an error code and ceases operation. This may turn out unhelpful, as the other threads are not notified and useful operation ceases. Since the occupation bit cannot be unset at this stage, any subsequent join statement will deadlock. Any values it would have returned are lost.

%------------------------------------------------
\chapter{Description of the Software}
\label{description_of_the_software}
The compiler consists of a number of haskell files, and some additional files. This chapter will go over the functions of each of those files.

\section{ASTBuilder.hs}
The purpose of the ASTBuilder is to build an Abstract Syntax Tree using a parsetree. The ASTBuilder also contains the functions to convert an AST to a RoseTree with or without debug information.

\section{BasicFunctions.hs}
Part of the Sprockell. Any changes in the Sprockell code have been annotated with \texttt{PP26:\ldots}.

\section{Checker.hs}
The checker does type checking on an AST and adds information about scopes (symboltable) to it. It works in two passes, first collecting information about global variables and procedures, then checking for all context constraints.

\section{CodeGen.hs}
CodeGen takes a checked AST and generates a program of SprIL instructions, runnable on Sprockells.

\section{Constants.hs}
Constants stores constant values used in the code generation. Simply aliases for memory addresses and offsets.

\section{FP\_{}ParserGen.hs}
Parser generator supplied by the course.

\section{Grammar.hs}
Grammar contains the grammar used in the compiler.

\section{HardwareTypes.hs}
Part of the Sprockell. Any changes in the Sprockell code have been annotated with \texttt{PP26:\ldots}.

\section{Main.hs}
Main file, used for compilation and execution of SHL programs. Read the README.md for information on how to use it.

\section{README.md}
Constains some information about the project in general (eg. the Trello board) and instructions on how to use the compiler.

\section{Simulation.hs}
Part of the Sprockell. Any changes in the Sprockell code have been annotated with \texttt{PP26:\ldots}.

\section{Sprockell.hs}
Part of the Sprockell. Any changes in the Sprockell code have been annotated with \texttt{PP26:\ldots}.

\section{System.hs}
Part of the Sprockell. Any changes in the Sprockell code have been annotated with \texttt{PP26:\ldots}.

\section{Test.hs}
Used for internal testing, contains functions to print and write debug information, show ASTs with and without debug information, show the parse tree, and show the token list.

\section{Tokenizer.hs}
Tokenizer tokenises a string into a list of tokens.

\section{Types.hs}
Contains all the Haskell types used during compilation, including Alphabet, AST, and checking/scope types.



%------------------------------------------------
\chapter{Test Plan \& Results}
\label{test_plan_and_results}


\section{Implemented Tests}
\label{implemented_tests}
Following is a list of all the test files that have been used to test the compiler, and a short description of their purpose.
\begin{mycompactdesc}
	\item[syntax1] Tests incorrect program syntax
	\item[syntax2] Tests incorrect procedure syntax
	\item[syntax3] Tests incorrect variable syntax
	\item[syntax4] Tests incorrect if syntax
	\item[syntax5] Tests incorrect expression syntax
	\item[wrong\_{}type] Tests whether a wrong type is detected
	\item[not\_{}declared] Tests whether a variable which has not been declared is detected
    \item[cyclic\_{}recursion] Tests for correct cyclic recursion
    \item[deep\_{}expression] Tests for correct evaluation of nested expressions
    \item[fib] Tests for correct evaluation of a Fibonacci procedure 
    \item[if] Tests a correct simple if statement
    \item[ifelse] Tests a correct simple if-else statement with some additional scoping
    \item[infinite\_{}busy\_{}loop] Tests behaviour in an empty infinite loop
    \item[infinite\_{}loop] Tests behaviour in an infinite loop with some operation in it. Also tests integer overflows, which are not detected.
    \item[nested\_{}procedures] Tests for correct evaluation of nested procedures
    \item[recursion] Tests for correct recursion
    \item[while] Tests a simple correct while statement
    \item[call\_{}by\_{}reference] Tests for correct multi-threaded call-by-reference
    \item[blocks] Tests for correct handling of scopes
    \item[simple\_{}proc] Tests a simple correct procedure
	\item[banking] Tests a concurrent banking application
    \item[peterson] Tests for correct evaluation of Peterson's algorithm
    \item[simple\_{}concurrency] Tests a simple correct concurrent program
    \item[multiple\_{}globals] Tests behaviour of concurrent printing of global variables
    \item[join\_{}test] Tests whether join behaviour is correct
\end{mycompactdesc}
The source code, generated code and results of all tests have been documented in \texttt{testreport.pdf}.

\section{Test Plan}
The testing has been roughly divided into three cases: syntax, context constraints and semantics. For the first two phases most of the testing of correct code occurs during the semantic testing and as informal testing during the building of those parts of the compiler. Some additional tests have been written to more formally test the incorrect code.

The shape of the parse tree and Abstract Syntax Tree have been extensively observed and checked during the building of the checking part of the compiler. This has mostly been done by slightly tweaking a program a multitude of times, to produce all intended shapes of the tree and attempting to produce unintended shapes, and building the trees. This part of the testing, as well as the previous part, have not been documented very well, and might therefore appear somewhat lacking compared to the semantic testing.

The semantics, or run-time, testing has been given the most time and effort, and checks for correctness of code generation and intended behaviour. Since very little run-time error are thrown (see \fullref{def:error_handling}), there are only a few tests of incorrect code, or code producing unintended effects.


\section{How To Run a Test}
\label{how_to_run_a_test}
To run a test, simply follow the \texttt{README.md}, using the following path: \texttt{test/<fileName>}, where \texttt{fileName} is one of the tests described above. Remember that for a concurrent program, which is any program that uses at least one fork statement, multiple Sprockells have to be used.


%------------------------------------------------
\chapter{Personal Evaluation}
\label{personal_evaluation}
\section{Martijn}
The project is actually quite fun to do once you have a better understanding of the time needed to deliver a working product. It helps too that stress factors like an FP-resit or falling behind on excercises are just not there. Even though I had to take the CP resit, most other grades were excellent and help in achieving a good average grade. The module as a whole is a lot of work, but is a lot more doable as a second-timer. Grades are better, workload is better. 

I am a great fan of the new functional programming excercises in week 4 and 5, they were a change in pace for us, but gave us the confidence to do this project fully in Haskell, which turned out to be a great choice in terms of motivation and having the overview. With ANTLR I feel like talking to a black box (even though they do roughly the same). The new Logic programming excercises and project are a great addition too, as they show more of the power of logic programming than last year's did.

That's all. As far as I can see we did our best. Let's hope it is enough.

\section{Tim}
I personally am quite satisfied with the language and compiler we built. It's a lot better than last year's, and think it should be quite usable this time. We decided to focus mostly on a simple set of things we wanted, and I believe we mostly delivered on those things. I know call-by-reference is somewhat iffy, it uses an internal value and only writes it back to the references variable at the end of the procedure, but that should be fine for sequential programs. For parallel programs, just stick with Peterson's algorithm if you need something to be mutually exclusive, which isn't just a single write.

I quite like the Programming Paradigms module, with the exception of concurrent programming. I find building a compiler quite interesting, and I really like function programming (we actually scored a 10 for the project), yet somehow concurrent programming just isn't really my thing. It just doesn't really capture my attention, and that shows in the results. The first test I just left early because it wasn't going to work out anyway, and I had to miss the second one because I got ill the day before, so I'm currently trying to get a third attempt.

I do have to say the workload of this module is still quite high, but mostly doable. It mostly just requires some good time management and work ethics, in which I occasionally lack a bit. The way the module is structured, mostly the CC exercises, means that occasionally you have to wait quite a bit for a student assistant to be available, but I found this much less of an issue than last year.

I cannot comment on the lectures this year, as I didn't go to most of them, seeing as I had been there last year. In retrospect it would have been a good idea to go to the CP lectures, but I can't do much about that now.

I finish this up, I enjoyed this module, with the exception of CP. There were a few problems along the way, but they quickly dealt with and weren't really an issue for me in the end. Every module can improve in some ways, but I would have to say I'm quite content with this one.


%------------------------------------------------
%	APPENDICES
%------------------------------------------------
\begin{appendices}
\label{appendices}


%------------------------------------------------
\chapter{Grammar Specification}
\label{grammar_specification}
\begin{landscape}
\inputminted[firstline=66, lastline=138, tabsize=4]{haskell}{../Grammar.hs}
\end{landscape}


%------------------------------------------------
\chapter{Extended Test Program}
\label{extended_test_program}
The extended test program shown here is Peterson's algorithm. It shows how, using the available methods for concurrency, two thread using the same variable have mutually exclusive access to it.

\section{Peterson's Algorithm Test}
\inputminted[tabsize=4,linenos,firstnumber=1]{text}{../test/peterson.shl}

\section{Generated Code}
\inputminted[tabsize=4,linenos,firstnumber=0]{text}{../test/peterson_gen.txt}

\section{Correct Executions}
Every time a value is printed in Peterson's algorithm test, it should be zero:
\begin{minted}[tabsize=4]{text}
What file do you want to run? Please provide the relative path excluding the extension.
test/peterson
How many Sprockells do you want to use to run this file?
3
Running: test/peterson.shl
On 3 Sprockells
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
>>> 0
\end{minted}


\end{appendices}

\end{document}
