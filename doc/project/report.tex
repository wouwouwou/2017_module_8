%------------------------------------------------
%	PACKAGES AND OTHER DOCUMENT CONFIGURATIONS
%------------------------------------------------

\documentclass[twoside]{report}

\usepackage{graphicx}

\usepackage{minted}

\usepackage{amsmath,amssymb,amsthm} % Mathematical Symbols, styles, etc

\usepackage[sc]{mathpazo} % Use the Palatino font
% Output encoding
\usepackage[T1]{fontenc} % Use 8-bit encoding that has 256 glyphs
% Input encoding
\usepackage[utf8]{inputenc} % UTF-8 character encoding stuff
\linespread{1.05} % Line spacing - Palatino needs more space between lines
\usepackage{microtype} % Slightly tweak font spacing for aesthetics

\usepackage[hmarginratio=1:1,top=32mm,columnsep=20pt]{geometry} % Document margins
\usepackage[hang, small,labelfont=bf,up,textfont=it,up]{caption} % Custom captions under/above floats in tables or figures
\usepackage{booktabs} % Horizontal rules in tables
\usepackage{float} % Required for tables and figures in the multi-column environment - they need to be placed in specific locations with the [H] (e.g. \begin{table}[H])
\usepackage{hyperref} % For hyperlinks in the PDF
\newcommand*{\fullref}[1]{\hyperref[{#1}]{\ref*{#1} (\nameref*{#1})}}
\newcommand*{\fullautoref}[1]{\hyperref[{#1}]{\autoref*{#1} (\nameref*{#1})}}

\usepackage{pdflscape} % For landscape pages

\usepackage{lettrine} % The lettrine is the first enlarged letter at the beginning of the text
\usepackage{paralist} % Used for the compactitem environment which makes bullet points with less space between them

\usepackage{titlesec} % Allows customization of titles
%\renewcommand\thesection{\Roman{section}} % Roman numerals for the sections
%\renewcommand\thesubsection{\Roman{subsection}} % Roman numerals for subsections
%\titleformat{\section}[block]{\large\scshape}{\thesection.}{1em}{} % Change the look of the section titles
%\titleformat{\subsection}[block]{\large}{\thesubsection.}{1em}{} % Change the look of the subsection titles

\usepackage{fancyhdr} % Headers and footers
\pagestyle{fancy} % All pages have headers and footers
\fancyhead{} % Blank out the default header
\fancyfoot{} % Blank out the default footer
\fancyhead[C]{M.F. Verkleij, W.F.A. Bos: \shorttitle} % Custom header text
\fancyfoot[RO,LE]{\thepage} % Custom footer text

% Appendices
\usepackage[toc,page]{appendix} % appendix

% Additional column type
\usepackage{array}
\newcolumntype{C}[1]{>{\centering\arraybackslash}p{#1}}

% hypperref
\usepackage{hyperref}

% Indentation of list
\usepackage{changepage}
\newenvironment{mycompactdesc}{\begin{adjustwidth}{0.53cm}{}\begin{compactdesc}}{\end{compactdesc}\end{adjustwidth}}

%------------------------------------------------
%	TITLE SECTION
%------------------------------------------------

\newcommand{\articletitle}{Programming Paradigms Final Project: Building a Compiler in Haskell for the Sprockell}
\newcommand{\shorttitle}{PP Final Project}

\title{\vspace{-15mm}\fontsize{24pt}{10pt}\selectfont\textbf{\articletitle}} % Article title

\author{
\large
\textsc{Group 33}\\[-0.75mm]
\textsc{Martijn Verkleij \& Wouter Bos}\\[2mm] % Your name
\normalsize University of Twente \\ % Your institution
\normalsize \href{mailto:m.f.verkleij@student.utwente.nl}{m.f.verkleij@student.utwente.nl},
\href{mailto:w.bos@student.utwente.nl}{w.f.a.bos@student.utwente.nl}\\% Your email addresses
\normalsize s1466895 s1606824
}

\date{\today}

%------------------------------------------------

\begin{document}

\thispagestyle{empty}
\maketitle % Insert title


%------------------------------------------------
%	ARTICLE CONTENTS
%------------------------------------------------

%------------------------------------------------
\tableofcontents


%------------------------------------------------
\chapter{Introduction}
\label{introduction}
In the Programming Paradigms course, the final project is a combination of compiler construction, functional programming, and concurrent programming. It requires its participants to build a compiler for a self-defined language, which targets SprIL, an in Haskell defined synthesized processor. The language has to support basic primitives like arithmetic expressions, 3GL control flow logic like if(-else) and while and must perform type checking on all expressions. Finally, basic concurrency must be incorporated in the language.

The language we (group 33) improved upon for this project is called Simple Haskell Language (SHL), with file extension \emph{.shl}. We are both repeat students, and decided upon improving the best of our two languages. The final project (SHL2.0) supports all the required features, as well as some additional features. These additional features include: procedures, call-by-reference and enumerations. The entire compiler runs on Haskell, both the code-generation and front end. The Sprockell was slightly extended as well, for feature parity with last year's implementation and convenience.


%------------------------------------------------
\chapter{Summary}
\label{summary}
This chapter will give a summary of the features of SHL2.0.
\paragraph{Data types} SHL supports three basic data types: integers, booleans and enumerations.
\paragraph{Simple expressions and variables} SHL supports denotations for primitive values of types as well as operations for (in)equality for values of types. SHL is strongly typed and all variables are initialised upon declaration. It also supports scoping with variable shadowing. Operator precedence is adhered to. If operators of equal precedence occur, the expression is interpreted left-to-right.

The following expressions are supported:
\begin{compactitem}
	\item Parentheses
	\item Assignment
	\item Binary operation (with ==, !=, <>, \&\&, ||, <=, >=, <, >, +, -, *)
	\item Prefix Unary operation (with !, -, +)
	\item Variable
	\item Integer value
	\item Boolean value
\end{compactitem}
\paragraph{Basic statements} SHL supports the following statements: 
\begin{compactitem}
	\item Block
	\item Declaration
	\item If 
	\item While
	\item Call
	\item Fork 
	\item Join
	\item Print
	\item Expression
\end{compactitem}
\paragraph{Concurrency} SHL supports global variables, fork and join statements to implement concurrency.
\paragraph{Procedures} SHL supports basic procedures with call-by-reference. Procedures have no return value.


%------------------------------------------------
\chapter{Problems \& Solutions}
\label{problems_and_solutions}
This chapter is a short discussion of some of the problems encountered during the project and their solutions.

\section{Expressions}
During the process of improving the compiler's expression handling, a couple of problems arose. Firstly, more types had to be declared in order to implement operator precedence in the tokenizer, grammar and AST-builder. These types included operators and grammar rules. New AST-node types were considered, but not needed. Furthermore, the new types had to be unambiguous, which meant defining other types than the ones used by the Sprockell and Haskell. \\
Secondly, defining the right grammar rules proved to be tricky. 
Since the compiler supports more operators than only plus, minus and asterisk, a classic LL(1) expression grammar had to be complemented with precedence rules for the other operators.  \\
Thirdly, there was a small problem with the pattern matching when building the AST out of the ParseTree. It took some time to figure out the right typing in the pattern matches and the building of operator nodes had to be though out thoroughly. \\
Lastly, after modifying the ASTBuilder there was still a problem with consecutively recurring operator classes being right-associative instead of left-associative. A solution has been found in implementing a rebalancing function just before the checker phase, in which a left-rotation is performed on an AST if such consecutively recurring operator classes are present.

\section{Enumerations}
The second improvement and therefore the second challenge which gave some problems, was implementing Enumerations into the SHL compiler. \\
Firstly, Enumerations had to be recognised and translated into the AST. This proved to be easier than expected. The real challenge was in type-checking and code-generation. An extra EnumerCheckerType has been added to be able to perform type-checking. This type-checking has then been implemented in the checker. Because of the extra checker-type, the code had to be changed in a lot of places, which was more time-consuming than planned. \\
Secondly and lastly, the generation of code was implemented. One problem in particular proved to be tricky in this stage, and that was the fact that initially the declared enumeration values were not unique and therefore, the first value of two different enumeration were equal in the perspective of the Sprockell. This has been fixed by giving each enumeration value a unique id. 

\section{New Sprockell}
Luckily we had few problems with the new version of the Sprockell. The most important change was the generated code to output strings out of the Sprockell. After changing one instruction name and after checking that every character was outputted correctly, this problem also has been solved.

\section{Time}
A big factor in each and every project is time. For this project a very specific time schedule has not been made. A generic planning including a task-list and task-division has been discussed multiple times through the process of improving SHL. Eventually, the amount of improvements are less than hoped for because more time has been spent on the re-take exam for the Concurrent Programming strand of the Programming Paradigms module. 


%------------------------------------------------
\chapter{Sprockell Extensions}
\label{sprockell_extensions}
All extensions which are mentioned below, are now implemented in Sprockell and are extensions from last year Sprockell's version. No alterations to the code generation were needed to correspond with the extensions discussed in this chapter.
\section{ComputeI Instruction}
\label{computei_instruction}
A compute with immediate value, \texttt{ComputeI operator reg value reg}. This instruction takes a register and a value to do a computation with the operator, which is then written to the second register. It is mostly used to calculate ARP offsets. This instruction was inspired by the \emph{iloc} instructions using an immediate value (eg. \texttt{AddI, SubI}. 

\section{Incr4 \& Decr4}
\label{incr4_and_decr4}
Two \texttt{Operator}s were added to the alu operators: Incr4 and Decr4. They were originally added to more easily do the steps of four to calculate offsets, before \texttt{ComputeI} was added. They are currently unused.


%------------------------------------------------
\chapter{Detailed Language Description}
\label{detailed_language_description}
This chapter will describe every feature of SHL in detail: providing a basic description; information on the syntax with at least one example; usage information along with restrictions; a description of its effects and execution; and some general information on the generated code.

%\section{General/collection}
%\subsection{Feature}
%\subsubsection*{Syntax}
%\subsubsection*{Usage}
%\subsubsection*{Semantics}
%\subsubsection*{Code Generation}

\subsection{Program}
\label{def:program}
\subsubsection*{Syntax}
\texttt{[GLOBAL]\ldots [ENUM]\ldots [PROCEDURE]\ldots [STATEMENTS]\ldots}\\
\begin{mycompactdesc}
	\item[GLOBAL] Global variable declarations as defined in \fullref{def:global}
	\item[ENUM] Enumeration declarations as defined in \fullref{def:enumeration}
	\item[PROCEDURE] Procedures as defined in \fullref{def:procedure}
	\item[STATEMENTS] Statements as defined in \fullref{def:statements}
\end{mycompactdesc}
\paragraph{Example}
\begin{minted}[tabsize=4]{text}
global int number = 5;

enum foo = {bar,baz};

procedure eq(int num1, int num2, bool out) {
	if (num1 == num2) {
		out = true;
	} else if (bar == bar) {
		out = false;
	}
}

int otherNumber = 6;
bool out;
eq(number, otherNumber, out);
print(out);
\end{minted}
\subsubsection*{Usage}
All files must follow the program syntax, and may only contain a single program.
\subsubsection*{Semantics}
A program is a collection of code which can be used to create an executable set of instructions. It is the root node of the Abstract Syntax Tree.
\subsubsection*{Code Generation}
Any program is generally built up as follows:
\begin{compactitem}
	\item \textbf{Thread control code}
	\begin{compactitem}
		\item \textbf{Thread Control Loop} \\ All extra threads loop here, waiting to accept fork calls.
		\item \textbf{PreCall forked procedures} \\ Once a sprockell accepts a fork call, it reads the AR from global memory, and starts execution.
		\item \textbf{PostCall forked procedures} \\ Once an auxilary sprockell finishes the procedure, this code handles cleanup.
	\end{compactitem}
	\item \textbf{Procedures \ref{def:procedure}}
	\item \textbf{Global declarations \ref{def:global}}
	\item \textbf{Main code}
	
	\item \textbf{Post-program code} \\ Stops auxilary threads.
\end{compactitem}


\subsection{Global}
\label{def:global}
\subsubsection*{Syntax}
\texttt{global <TYPE> <ID> [= <EXPRESSION>] ;}
\begin{mycompactdesc}
	\item[TYPE] A type as defined in \fullref{def:types}
	\item[ID] A string as defined by \fullref{def:variable}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
global bool flag = true;
global int number;
\end{minted}
\subsubsection*{Usage}
Used to declare global variables and an optional assignment.  The type of the expression must match the type of the global variable.

All global variables MUST be defined at the top of the program, even before procedures.

The id of a global variable is unique in the whole program. No other variable of procedure may use the same id. They can therefore not be shadowed.
\subsubsection*{Semantics}
The global variable declaration reserves a space in shared memory and writes a value to it. All global variables are initialized to the default value (see \fullref{def:integer} and \fullref{def:boolean}) if no value is explicitly assigned.

Global variables are reachable from anywhere below its declaration in the code, in any thread. Beware, however, that the variable can be written to from any thread as well, and using the shared memory is significantly slower than using the local memory.

Globals that are passed as arguments to a procedure have their own intricacies, see \ref{def:call-by-reference} for more information.

\subsubsection*{Code Generation}
All globals are saved in global memory. Writes and reads to globals are done atomically, but assignments are not. This avoids data races, but to ensure atomicity on the whole assignment, one must implement his own mutual exclusion.


\subsection{Enumeration}
\label{def:enumeration}
\subsubsection*{Syntax}
\texttt{enum <ID> = \{ <VAR> [, <TYPE> <VAR>]\ldots ) \}}

\begin{mycompactdesc}
	\item[ID] A string as defined in \fullref{def:variable}
	\item[VAR] A string as defined in \fullref{def:variable}
\end{mycompactdesc}

\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
enum foo = {bar}
enum test = {test1, test2}
\end{minted}

\subsubsection*{Usage}
Used to declare an enumeration. Enumerations are all equal, as in, the compiler does not type check individual enumerations from each other, due to time constraints.

The ID of an enumeration, a well as it's values must be unique in the program.


\subsubsection*{Semantics}
Enumerations are usable everywhere in the program. Enumerations can only be checked for equality with each other.

\subsubsection*{Code Generation}
During code generation, all enumerated values are mapped onto integer values. Literal enum values emit this mapped integer value. As they are type checked for comparison by equality only, arithmetic operations are impossible. For their declaration, no code is emitted.

\subsection{Procedure}
\label{def:procedure}
\subsubsection*{Syntax}
\texttt{procedure <ID> ( [<TYPE> <VAR>] [, <TYPE> <VAR>]\ldots ) <STATEMENT>...}
\begin{mycompactdesc}
	\item[ID] A string as defined in \fullref{def:variable}
	\item[TYPE] A type as defined in \fullref{def:types}
	\item[VAR] A variable as defined in \fullref{def:variable}
	\item[STATEMENT] A statement as defined in \fullref{def:statements}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
procedure empty() print(0);
procedure other(int num, bool flip) {
	while ((num > 0)) {
		num = --num;
		flip = !flip;
	}
	print(num, flip);
}
\end{minted}
\subsubsection*{Usage}
Used to declare a procedure. Because call-by-reference (see \fullref{def:call-by-reference}) is used, a variable passed as an argument can be used to write resulting values. One could also use the global variables (see \fullref{def:global}), as they are accessible from everywhere.

The id of a procedure is unique in the whole program. No other variable of procedure may use the same id.
\subsubsection*{Semantics}
A procedure is section of code that can be executed from anywhere, using a call or fork statement (see \fullref{def:call} and \fullref{def:fork}) and passing the appropriate number of arguments to it.
\subsubsection*{Code Generation}
Procedure code has the following structure:
\begin{compactitem}
	\item \textbf{PostCall code} \\ Copies all arguments into the local data area for use. 
	\item \textbf{Procedure's statements}
	\item \textbf{PreReturn code} \\ The final result of all arguments is read, and if they are global or local variables, saved to the appropriate location.
\end{compactitem}


\section{Statements}
\label{def:statements}


\subsection{Declaration}
\label{def:declaration}
\subsubsection*{Syntax}
\texttt{<TYPE> <ID> [= <EXPRESSION>] ;}
\begin{mycompactdesc}
	\item[TYPE] A type as defined in \fullref{def:types}
	\item[ID] A string as defined in \fullref{def:variable}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
int number = 1+1;
bool flag;
\end{minted}
\subsubsection*{Usage}
Used to declare local variables and an optional assignment. The type of the expression must match the type of the variable.

The id of a variable is unique in the scope it is defined in. No other variable in that scope may use the same id.
\subsubsection*{Semantics}
The variable declaration writes the value of the variable to the Local Data Area of where it was (most recently) defined. All variables are initialized to the default value (see \fullref{def:integer} and \fullref{def:boolean}) if no value is explicitly assigned.
\subsubsection*{Code Generation}
A declaration evaluates the expression behind it before assigning it to the variable. The variable's value is saved in the appropriate Local Data Area, by following the scopes upward until the right scope is reached, after which it is saved with an offset.

\subsection{If}
\label{def:if}
\subsubsection*{Syntax}
\texttt{if ( <EXPRESSION> ) <STATEMENT> [else <STATEMENT>]}
\begin{mycompactdesc}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
	\item[STATEMENT] A statement as defined in \fullref{def:statements}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
if (flag) {
	// do something
}
if (flag) print(flag); else {
	// do something
}
\end{minted}
\subsubsection*{Usage}
Execute a section of code based on an expression. The type of this expression must be a boolean.
\subsubsection*{Semantics}
If the expression evaluates to \emph{true}, execute the first statement. If it evaluates to \emph{false}, execute the code after the first statement, which can be either the second statement or the code that comes after the if statement.
\subsubsection*{Code Generation}
First the expression will be evaluated, after which a branch jumps to the else block upon a false result, or to the next expression if no else block is present. After the if-block, a jump to after the else block is placed when an else block is present.

\subsection{While}
\label{def:while}
\subsubsection*{Syntax}
\texttt{while ( <EXPRESSION> ) <STATEMENT>}
\begin{mycompactdesc}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
	\item[STATEMENT] A statement as defined in \fullref{def:statements}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
while (flag) {
	// do something
}
\end{minted}
\subsubsection*{Usage}
Execute a section of code while the expression is \emph{true}. The type of this expression must be a boolean.
\subsubsection*{Semantics}
If the expression evaluates to \emph{true}, execute the statement. Repeat this for as long as the expression keeps evaluating to \emph{true}.
\subsubsection*{Code Generation}
As long as the expression is true, the code in the following block will be executed. The expression is re-evaluated after each execution of the block.


\subsection{Fork}
\label{def:fork}
\subsubsection*{Syntax}
\texttt{fork <ID> ( [<EXPRESSION> [, <EXPRESSION>]\ldots] ) ;}
\begin{mycompactdesc}
	\item[ID] A string as defined by \fullref{def:variable}
	\item[EXPRESSION] An expression as defined by \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
fork proc0();
fork proc1(flag);
fork proc2(5, flag = true);
\end{minted}
\subsubsection*{Usage}
Run a procedure, which must have been declared somewhere, on a separate thread. The expression types must match the types defined during the procedure declaration (see \fullref{def:procedure}).
\subsubsection*{Semantics}
Writes the argument to shared memory and tells the thread pool to start parallel execution of the procedure.

Beware, if more procedures are given to the thread pool than there are threads, fork may have to wait for a thread to finish its work before continuing execution. In the case where programs with forks are executed on only one sprockell, it will deadlock.
\subsubsection*{Code Generation}
A fork call must start a procedure in another thread. To accomplish this, the first 30 addresses in global memory are reserved for this purpose. A further few addresses, namely as much as there are threads, are reserved for an occupation bit. In practise this means that procedures with more than 7 arguments cannot be forked without memory corrupting.

The addresses are reserved as follows:

\begin{compactitem}
	\item \textbf{End flag} \\ Set when the auxilary threads may cease execution. Each auxilary sprockell checks this record before attempting to read an AR from shared memory  
	\item \textbf{Wr flag} \\ Used to set the AR space as occupied by an AR that may be executed. An auxilary threads sets it to 0 when it has read the AR.
	\item \textbf{Rd flag} \\ Read-protects the AR as it is being written, and to exclude other sprockells from handling the request.
	\item \textbf{Jump index} \\ line number of the procedure to execute.
	\item \textbf{Argument count} \\ Number of arguments that follow.
	\item \textbf{Arguments...}
	\begin{compactitem}
		\item \textbf{Value}
		\item \textbf{Local address} \\ The address to write the result back to, if the argument has one. For example, an expression has none.
		\item \textbf{Global address} \\  Idem.
	\end{compactitem}
\end{compactitem}




\subsection{Join}
\label{def:join}
\subsubsection*{Syntax}
\texttt{join ;}
\paragraph{Example}
\begin{minted}[tabsize=4]{text}
join;
\end{minted}
\subsubsection*{Usage}
Ensures all auxilary threads have finished execution before continuing. 
\subsubsection*{Semantics}
Blocks execution of the main thread until all other threads have finished their work. May only be called in code that is not executed in auxilary threads, for example by calling a procedure with fork that contains a join statement.
\subsubsection*{Code Generation}
A join statement iterates over the occupation bits of all auxilary threads. Only if they are all zero, this statement may end. It will therefore throw an error when called from an auxilary thread, as can happen when used in a procedure.


\subsection{Call}
\label{def:call}
\subsubsection*{Syntax}
\texttt{<ID> ( [<EXPRESSION> [, <EXPRESSION>]\ldots] ) ;}
\begin{mycompactdesc}
	\item[ID] A string as defined by \fullref{def:variable}
	\item[EXPRESSION] An expression as defined by \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
proc0();
proc1(flag);
proc2(5, flag = true);
\end{minted}
\subsubsection*{Usage}
Execute the called procedure sequentially, which must have been declared. The expressions must have the same types as the procedure's as defined in its declaration (see \fullref{def:procedure})
\subsubsection*{Semantics}
Go to the procedure code and execute the procedure with the expressions, then return to the call.
\subsubsection*{Code Generation}
Calls a procedure sequentially. Any separate variables that are given as an argument are handled call-by-reference. Sets up the AR before jumping to the procedure. 


\subsection{Expression}
\label{def:expression_statement}
\subsubsection*{Syntax}
\texttt{<EXPRESSION> ;}
\begin{mycompactdesc}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
a = (5 + (--b));
true;
-+a;
++a;
\end{minted}
\subsubsection*{Usage}
Allows expressions to be executed as statements. The only useful purpose is to increment or decrement a variable with a prefix unary operator.
\subsubsection*{Semantics}
Execute the expression, this generally has no effects, except for an increment or a decrement of a variable.
\subsubsection*{Code Generation}
As expressions have a result on stack, one must pop this value if the expression is defined as a statement. Otherwise the stack would fill up. One special case has been made for increments and decrements.


\subsection{Block}
\label{def:block}
\subsubsection*{Syntax}
\texttt{\{ [STATEMENT]\ldots \}}
\begin{mycompactdesc}
	\item[STATEMENT] A statement as defined in \fullref{def:statements}
\end{mycompactdesc}
\paragraph{Example}
\begin{minted}[tabsize=4]{text}
{
	int i = 0;
	{
		i = ++i;
		{
			int i = 5;
		}
		print(i == 1);
	}
	print(i == 1);
}
\end{minted}
\subsubsection*{Usage}
A block is a single statement that contains zero or more statements. It is mostly used within procedures and statements to executes more than one statement.
\subsubsection*{Semantics}
A block opens a new scope, then executes the code within. When exiting a block, the scope is closed.
\subsubsection*{Code Generation}
As any block opens a new scope, a new mini-AR is created for each scope. It only contains a pointer to it's parent's AR and all variables declared in this scope in a Local Data Area.


\subsection{Print}
\label{def:print}
\subsubsection*{Syntax}
\texttt{print ( <EXPRESSION> [, <EXPRESSION>]\ldots ) ;}
\begin{mycompactdesc}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
print(a);
print(true, 5, 1983);
print(a = ++a, (11 - 2) * a));
\end{minted}
\subsubsection*{Usage}
Prints values of evaluated expressions to the console.
\subsubsection*{Semantics}
Evaluates the expressions and prints the values as they appear in memory, meaning a boolean is represented as either a zero (\emph{false}) or a one (\emph{true}).
\subsubsection*{Code Generation}
As SprIL does not have a print instruction, a new one was created and added to the Sprockell source code. See also chapter \ref{sprockell_extensions}. This statement simply evaluates all expressions in its arguments and prints them one per line.


\subsection{Assignment}
\label{def:assignment}
\subsubsection*{Syntax}
\texttt{<ID> = <EXPRESSION>}
\begin{mycompactdesc}
	\item[ID] A string as defined in \fullref{def:variable}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
a = 5;
b = c <> d && e;
\end{minted}
\subsubsection*{Usage}
Used to assign a value, in the form of an expression, to a variable. The variable must have been declared beforehand, and may be either global or local. The type of the expression must match the type of the variable.
\subsubsection*{Semantics}
Assignment evaluates the expression and writes it to the address of the variable.
\subsubsection*{Code Generation}
First, the expression will be evaluated. The result is assigned to the variable, may it be in local or global memory. These are resolved by AR traversal and lookup in a static table respectively. The result is pushed to the stack.


\section{Expressions}
\label{def:expressions}


\subsection{Parentheses}
\label{def:parentheses}
\subsubsection*{Syntax}
\texttt{( <EXPRESSION> )}
\begin{mycompactdesc}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
\end{mycompactdesc}
\paragraph{Example}
\begin{minted}[tabsize=4]{text}
a = -(-(--a); // the same as: a = (-1) * (-1) * (a - 1);
\end{minted}
\subsubsection*{Usage}
Parentheses are used to enforce which operator is used (see the example above). It can also be used to enforce the order in which an expression is evaluated, but since this already explicitly happens (see \fullref{def:operation}) it should not be necessary to use a parentheses expression for it.
\subsubsection*{Semantics}
Everything between the parentheses is evaluated and the value is returned as the result of this expression.
\subsubsection*{Code Generation}
Required around any binary expression and optional around unary expressions to, as in the example, differentiate between the negation and decrement operator. The result of the inner expression is pushed to stack.


\subsection{Variable}
\label{def:variable}
\subsubsection*{Syntax}
\texttt{<ID>}
\begin{mycompactdesc}
	\item[ID] A string, starting with a letter, which may use any alphanumerical character in addition to the following characters: \emph{\~{}`'"@\#\$\textbackslash.?:\_{}}
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
a
a@__b"42"\#1337'
\end{minted}
\subsubsection*{Usage}
A variable must be declared (see \fullref{def:declaration}) before use. It has a type which is determined upon declaration.
\subsubsection*{Semantics}
Evaluation of a variable returns its value.
\subsubsection*{Code Generation}
The variable's value is looked up in the AR stack or loaded from global memory and pushed to stack.


\subsection{Integer}
\label{def:integer}
\subsubsection*{Syntax}
\texttt{<INTEGER>}
\begin{mycompactdesc}
	\item[INTEGER] An integer string
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
42
1337
0000004201337
\end{minted}
\subsubsection*{Usage}
Takes the value of the integer, removes leading zeros.
\subsubsection*{Semantics}
Upon evaluation it returns its integer value.
\subsubsection*{Code Generation}
Its value is pushed to stack.


\subsection{Boolean}
\label{def:boolean}
\subsubsection*{Syntax}
\texttt{<BOOLEAN>}
\begin{mycompactdesc}
	\item[BOOLEAN] Where a boolean is either "\texttt{true}" or "\texttt{false}"
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
true
false
\end{minted}
\subsubsection*{Usage}
Takes the value of the boolean (either one or zero) and returns it.
\subsubsection*{Semantics}
Upon evaluation, return the corresponding binary representation of the boolean, where \emph{false} equals zero and \emph{true} equals one.
\subsubsection*{Code Generation}
Its value is pushed to stack.

\subsection{Enumeration}
\label{def:statenum}
\subsubsection*{Syntax}
\texttt{<ENUM>}
\begin{mycompactdesc}
	\item[ENUM] A string that is equal to a declared enum value.
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}

foo

\end{minted}
\subsubsection*{Usage}
Pushes the mapped enum value to the stack.
\subsubsection*{Semantics}
Upon evaluation, return the corresponding mapped value of the enum value.
\subsubsection*{Code Generation}
Its value is looked up in a generated enum mapping table, and pushes its value to stack.


\subsection{Operation}
\label{def:operation}
\subsubsection*{Syntax}
\texttt{<EXPRESSION> <OPERATOR> <EXPRESSION>}
\begin{mycompactdesc}
	\item[EXPRESSION] An expression as defined in \fullref{def:expressions}
	\item[OPERATOR] One of the following operators: \texttt{==, !=, \&\&, ||, <>, <=, >=, <, >, +, -, *} (see \fullref{def:operators})
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
(true <> b)
((a + b) == (c + d))
\end{minted}
\subsubsection*{Usage}
Apply operator on two expressions. Both expressions must be of the same type, which must also match one of the types supported by the operator.
\subsubsection*{Semantics}
After both expressions have been evaluated, the operation is evaluated and its result will be returned.
\subsubsection*{Code Generation}
It's left- and right hand side are evaluated, and its results are used as arguments to the operation. The result of the operation is pushed to stack.


\subsection{Prefix Unary Operation}
\label{def:prefix_unary_operation}
\subsubsection*{Syntax}
\texttt{<OPERATOR> <EXPRESSION>}
\begin{mycompactdesc}
	\item[OPERATOR] One of the following operators: \texttt{---, ++, +, -, !} (see \fullref{def:operators})
\end{mycompactdesc}
\paragraph{Examples}
\begin{minted}[tabsize=4]{text}
!b
-(--a)
---a // is the same as: --(-a)
\end{minted}
\subsubsection*{Usage}
Apply operator on the expression. The expression type must match one of the types supported by the operator.
\subsubsection*{Semantics}
After the expression has been evaluated, the operation is evaluated and its result will be returned.
\subsubsection*{Code Generation}
It's right hand side is evaluated, fed to the operator and its result is pushed to stack.


\section{Other Features}
\label{def:other_features}


\subsection{Types}
\label{def:types}
\subsubsection*{Syntax}
\texttt{<TYPE>}
\begin{mycompactdesc}
	\item[TYPE] \texttt{int}, \texttt{bool} or \texttt{enum}
\end{mycompactdesc}


\subsection{Operators}
\label{def:operators}
\subsubsection*{Syntax}
\texttt{<OPERATOR>}
\begin{mycompactdesc}
	\item[OPERATOR] One of the following: \texttt{==, !=, \&\&, ||, <>, <=, >=, <, >, +, -, *, --, ++, !}
\end{mycompactdesc}
\subsubsection*{Usage}
\begin{mycompactdesc}
	\item[OPERATOR] Operation: \texttt{supported types} $\rightarrow$ \texttt{return type}
	\item[==] equals: \texttt{int, bool} $\rightarrow$ \texttt{bool, enum} $\rightarrow$ \texttt{bool}
	\item[!=] not equals: \texttt{int, bool} $\rightarrow$ \texttt{bool, enum} $\rightarrow$ \texttt{bool}
	\item[\&\&] and: \texttt{bool} $\rightarrow$ \texttt{bool}
	\item[||] or: \texttt{bool} $\rightarrow$ \texttt{bool}
	\item[<>] xor: \texttt{bool} $\rightarrow$ \texttt{bool}
	\item[<=] lesser than or equals: \texttt{int} $\rightarrow$ \texttt{bool}
	\item[>=] greater than or equals: \texttt{int} $\rightarrow$ \texttt{bool}
	\item[<] lesser than: \texttt{int} $\rightarrow$ \texttt{bool}
	\item[>] greater than: \texttt{int} $\rightarrow$ \texttt{bool}
	\item[+] add: \texttt{int} $\rightarrow$ \texttt{int}
	\item[-] subtract: \texttt{int} $\rightarrow$ \texttt{int}
	\item[*] multiply: \texttt{int} $\rightarrow$ \texttt{int}
	\item[--] decrement: \texttt{int} $\rightarrow$ \texttt{int}
	\item[++] increment: \texttt{int} $\rightarrow$ \texttt{int}
	\item[!] not: \texttt{bool} $\rightarrow$ \texttt{bool}
\end{mycompactdesc}


\subsection{Call-by-reference}
\label{def:call-by-reference}
SHL uses call-by-reference on calls to procedures. This is almost essential to make procedures useful, as the only other option to communicate values between a procedure and its caller would be through global memory. 

It is implemented by passing an optional return address in shared and local memory to write the result back to after the procedure is complete. In theory an argument could be written to both at the same time, as a memory slot is used for each (and makes them distinguishable). These are used to write the results back to their memory locations before returning to the caller.


To make use of it, pass any variable as a naked argument to a call to any procedure in the program. Expressions like \texttt{(i+3)} or \texttt{i = 12} do NOT work, as the argument will only be seen as an expression and will therefore not have a memory location associated with it. Keep in mind that any global variables passed as an argument will be written to global memory upon completion of the procedure. This does not influence any assignment inside the procedure, these are still done as they are evaluated.


\subsection{Error Handling}
\label{def:error_handling}
The SHL compiler does not support proper exception handling, but does throw errors of varying usefulness. During the tokenization phase, the only error thrown is an illegal character error.

During the parsing phase, the only error which might be thrown is a token list not fully parsed error, indicating the grammar cannot parse the token list.

The checker phase thrown different kinds of errors, all related to context constraints, they generally indicate the function which throws the error as well as printing some of the responsible data.

The code generation and runtime phases thrown the following kinds of errors:

Upon code generation, an error is thrown when a user attempts to compile code with a fork statement with the intention of using only one thread.

During runtime, when a join statement is executed by a thread other than the main thread, it prints an error code and ceases operation. This may turn out unhelpful, as the other threads are not notified and useful operation ceases. Since the occupation bit cannot be unset at this stage, any subsequent join statement will deadlock. Any values it would have returned are lost.

%------------------------------------------------
\chapter{Description of the Software}
\label{description_of_the_software}
The compiler consists of a number of Haskell files, and some additional files. This chapter will go over the functions of each of those files. It is assumed that the Sprockell has been installed from the GitHub repository which has been referenced by the teachers.

\section{ASTBuilder.hs}
The purpose of the ASTBuilder is to build an Abstract Syntax Tree using a parsetree. The ASTBuilder also contains the functions to convert an AST to a RoseTree with or without debug information.

\section{Checker.hs}
The checker does type checking on an AST and adds information about scopes (symboltable) to it. It works in two passes, first collecting information about global variables and procedures, then checking for all context constraints.

\section{CodeGen.hs}
CodeGen takes a checked AST and generates a program of SprIL instructions, runnable on Sprockells.

\section{Constants.hs}
Constants stores constant values used in the code generation. Simply aliases for memory addresses and offsets.

\section{FP\_{}ParserGen.hs}
Parser generator supplied by the course.

\section{Grammar.hs}
Grammar contains the grammar used in the compiler.

\section{Main.hs}
Main file, used for compilation and execution of SHL programs. Read the README.md for information on how to use it.

\section{README.md}
Contains some information about the project in general (eg. the Trello board) and instructions on how to use the compiler.

\section{Test.hs}
Used for internal testing, contains functions to print and write debug information, show ASTs with and without debug information, show the parse tree, and show the token list.

\section{Tokenizer.hs}
Tokenizer tokenises a string into a list of tokens.

\section{Types.hs}
Contains all the Haskell types used during compilation, including Alphabet, AST, and checking/scope types.



%------------------------------------------------
\chapter{Test Plan \& Results}
\label{test_plan_and_results}


\section{Implemented Tests}
\label{implemented_tests}
Following is a list of all the test files that have been used to test the compiler, and a short description of their purpose.
\begin{mycompactdesc}
	\item[syntax1] Tests incorrect program syntax
	\item[syntax2] Tests incorrect procedure syntax
	\item[syntax3] Tests incorrect variable syntax
	\item[syntax4] Tests incorrect if syntax
	\item[syntax5] Tests incorrect expression syntax
	\item[wrong\_{}type] Tests whether a wrong type is detected
	\item[not\_{}declared] Tests whether a variable which has not been declared is detected
    \item[cyclic\_{}recursion] Tests for correct cyclic recursion
    \item[deep\_{}expression] Tests for correct evaluation of nested expressions
    \item[fib] Tests for correct evaluation of a Fibonacci procedure 
    \item[if] Tests a correct simple if statement
    \item[ifelse] Tests a correct simple if-else statement with some additional scoping
    \item[infinite\_{}busy\_{}loop] Tests behaviour in an empty infinite loop
    \item[infinite\_{}loop] Tests behaviour in an infinite loop with some operation in it. Also tests integer overflows, which are not detected.
    \item[nested\_{}procedures] Tests for correct evaluation of nested procedures
    \item[recursion] Tests for correct recursion
    \item[while] Tests a simple correct while statement
    \item[call\_{}by\_{}reference] Tests for correct multi-threaded call-by-reference
    \item[blocks] Tests for correct handling of scopes
    \item[simple\_{}proc] Tests a simple correct procedure
	\item[banking] Tests a concurrent banking application
    \item[peterson] Tests for correct evaluation of Peterson's algorithm
    \item[simple\_{}concurrency] Tests a simple correct concurrent program
    \item[multiple\_{}globals] Tests behaviour of concurrent printing of global variables
    \item[join\_{}test] Tests whether join behaviour is correct
\end{mycompactdesc}
The source code, generated code and results of all tests have been documented in \texttt{testreport.pdf}.

\section{Test Plan}
The testing has been roughly divided into three cases: syntax, context constraints and semantics. For the first two phases most of the testing of correct code occurs during the semantic testing and as informal testing during the building of those parts of the compiler. Some additional tests have been written to more formally test the incorrect code.

The shape of the parse tree and Abstract Syntax Tree have been extensively observed and checked during the building of the checking part of the compiler. This has mostly been done by slightly tweaking a program a multitude of times, to produce all intended shapes of the tree and attempting to produce unintended shapes, and building the trees. This part of the testing, as well as the previous part, have not been documented very well, and might therefore appear somewhat lacking compared to the semantic testing.

The semantics, or run-time, testing has been given the most time and effort, and checks for correctness of code generation and intended behaviour. Since very little run-time error are thrown (see \fullref{def:error_handling}), there are only a few tests of incorrect code, or code producing unintended effects.


\section{How To Run a Test}
\label{how_to_run_a_test}
To run a test, simply follow the \texttt{README.md}, using the following path: \texttt{test/<fileName>}, where \texttt{fileName} is one of the tests described above. Remember that for a concurrent program, which is any program that uses at least one fork statement, multiple Sprockells have to be used.


%------------------------------------------------
\chapter{Personal Evaluation}
\label{personal_evaluation}
\section{Martijn}
The project is actually quite fun to do once you have a better understanding of the time needed to deliver a working product. It helps too that stress factors like an FP-resit or falling behind on exercises are just not there. Even though I had to take the CP resit, most other grades were excellent and help in achieving a good average grade. The module as a whole is a lot of work, but is a lot more doable as a second-timer. Grades are better, workload is better. 

I am a great fan of the parser generator functional programming exercises, they were a change in pace for us, but gave us the confidence to do this project fully in Haskell which turned out to be a great choice in terms of motivation and having the overview. With ANTLR I feel like talking to a black box (even though ANTLR is easier to define a language in due to left-recursiveness, LL$_X$ and so on). The new Logic programming exercises and project are a great addition too, as they show more of the power of logic programming than last year's did.

That's all. As far as I can see we did our best. Let's hope it is enough.

%TODO Fill in!
\section{Wouter}



%------------------------------------------------
%	APPENDICES
%------------------------------------------------
\begin{appendices}
\label{appendices}


%------------------------------------------------
\chapter{Grammar Specification}
\label{grammar_specification}
\begin{landscape}
\inputminted[firstline=66, lastline=142, tabsize=4]{haskell}{../../src/haskell/PP-project-2017/Grammar.hs}
\end{landscape}


%------------------------------------------------
\chapter{Extended Test Program}
\label{extended_test_program}
The extended test program shown here is Peterson's algorithm. It shows how, using the available methods for concurrency, two thread using the same variable have mutually exclusive access to it.

\section{Peterson's Algorithm Test}
\inputminted[tabsize=4,linenos,firstnumber=1]{text}{../../src/haskell/PP-project-2017/test/peterson.shl}

\section{Correct Executions}
Every time a value is printed in Peterson's algorithm test, it should be zero. The output of a simulation on the Sprockell with our compiler:
\begin{minted}[tabsize=4]{text}
What file do you want to run? Please provide the relative path excluding the extension.
test/peterson
How many Sprockells do you want to use to run this file?
3
Running: test/peterson.shl
On 3 Sprockells
Sprockell 0 says 0
Sprockell 0 says 0
Sprockell 0 says 0
Sprockell 0 says 0
Sprockell 0 says 0
Sprockell 0 says 0
Sprockell 0 says 0
Sprockell 0 says 0
Sprockell 0 says 0
Sprockell 0 says 0
Sprockell 0 says 0
Sprockell 0 says 0
Sprockell 0 says 0
Sprockell 0 says 0
Sprockell 0 says 0
Sprockell 0 says 0
Sprockell 0 says 0
Sprockell 0 says 0
Sprockell 0 says 0
Sprockell 0 says 0
\end{minted}


\end{appendices}

\end{document}
