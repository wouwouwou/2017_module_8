% !TEX TS-program = pdflatex
% !TEX encoding = UTF-8 Unicode

% This is a simple template for a LaTeX document using the "article" class.
% See "book", "report", "letter" for other types of document.

\documentclass[11pt]{article} % use larger type; default would be 10pt

\usepackage[utf8]{inputenc} % set input encoding (not needed with XeLaTeX)

%%% Examples of Article customizations
% These packages are optional, depending whether you want the features they provide.
% See the LaTeX Companion or other references for full information.

%%% PAGE DIMENSIONS
\usepackage{geometry} % to change the page dimensions
\geometry{a4paper} % or letterpaper (US) or a5paper or....
% \geometry{margin=2in} % for example, change the margins to 2 inches all round
% \geometry{landscape} % set up the page for landscape
%   read geometry.pdf for detailed page layout information

\usepackage{graphicx} % support the \includegraphics command and options
\usepackage{float}

% \usepackage[parfill]{parskip} % Activate to begin paragraphs with an empty line rather than an indent

%%% PACKAGES
\usepackage{booktabs} % for much better looking tables
\usepackage{array} % for better arrays (eg matrices) in maths
\usepackage{paralist} % very flexible & customisable lists (eg. enumerate/itemize, etc.)
\usepackage{verbatim} % adds environment for commenting out blocks of text & for better verbatim
\usepackage{subfig} % make it possible to include more than one captioned figure/table in a single float
% These packages are all incorporated in the memoir class to one degree or another...

%%% HEADERS & FOOTERS
\usepackage{fancyhdr} % This should be set AFTER setting up the page geometry
\pagestyle{fancy} % options: empty , plain , fancy
\renewcommand{\headrulewidth}{0pt} % customise the layout...
\lhead{}\chead{}\rhead{}
\lfoot{}\cfoot{\thepage}\rfoot{}

%%% SECTION TITLE APPEARANCE
\usepackage{sectsty}
\allsectionsfont{\sffamily\mdseries\upshape} % (See the fntguide.pdf for font help)
% (This matches ConTeXt defaults)

%%% ToC (table of contents) APPEARANCE
\usepackage[nottoc,notlof,notlot]{tocbibind} % Put the bibliography in the ToC
\usepackage[titles,subfigure]{tocloft} % Alter the style of the Table of Contents
\renewcommand{\cftsecfont}{\rmfamily\mdseries\upshape}
\renewcommand{\cftsecpagefont}{\rmfamily\mdseries\upshape} % No bold!

%% Automata
\usepackage{pgf}
\usepackage{tikz}
\usetikzlibrary{arrows,automata,positioning}
\usepackage{tikz-qtree}

%% Rotate text in tables etc.
\def\rot{\rotatebox}

%%% END Article customizations


%%% The "real" document content comes below...

\title{Exercises Compiler Construction}
\author{Martijn Verkleij (s1466895) \& Wouter Bos (s1606824)}
%\date{} % Activate to display a given date or no date (if empty),
         % otherwise the current date is printed 

\begin{document}
\maketitle

\section*{Exercise 1}

\bgroup
\def\arraystretch{1.5}
\begin{tabular}{lp{10cm}}
\textbf{Term} & \textbf{Meaning} \\
\hline
AST
& Abstract Syntax Tree. It only shows the abstract syntactic structure of the source code. A parse tree retains all information of the source code, while an AST only shows the information related to the syntactic structure. \\

DAG
& Directed Acyclic Graph. It is a directed graph with no directed cycles. There is no way to start at a node n and follow a sequence of edges that eventually loops back to n again. \\

Basic Block
& A maximal length sequence of straightline, or branch-free, code. A basic block is a sequence of operations that always execute together, unless an operation raises an exception. Control always enters a basic block at its first operation and exits at its last operation. \\

CFG
& Context-free Grammar. A formal grammar in which every production rule is of the form V $\rightarrow$ w, where V is a single nonterminal and w is a string of terminals and nonterminals or empty. \\

& Control Flow Graph. A representation of all paths that might be transversed during the execution of a program. \\

Dependence Graph
& A directed graph representing the dependencies of objects towards each other. \\

Call Graph
& A flow graph that represents calling relationships between subroutines in a program. \\

SSA
& Static Single Assignment. Each variable is assigned exactly once, and each variable is defined before it is used. \\

Symbol Table
& A data structure where each identifier is associated with information relating to its declaration or appearance in the program. \\

\hline
\end{tabular}
\egroup

\section*{Exercise 2.1}
\begin{tikzpicture}
\node (A) {1};
\node (B) [below of = A]{2};
\node (C) [below of = B]{3};
\node (D) [below of = C]{4};
\node (E) [below of = D]{5};
\node (F) [below of = E]{6};
\node (G) [below of = F]{7};
\node (J) [left of = E]{10};

\draw[->] (A) -- (B);
\draw[->] (B) -- (C);
\draw[->] (C) -- (D);
\draw[->] (D) -- (E);
\draw[->] (E) -- (F);
\draw[->] (F) -- (G);
\draw[->] (F) .. controls +(right:25pt) and +(right:25pt) .. (D);
\draw[->] (G) .. controls +(right:55pt) and +(right:55pt) .. (D);
\draw[->] (D.west) .. controls +(left:15pt) and +(up:15pt) .. (J.north);

\end{tikzpicture}

\section*{Exercise 2.2}
(1, 2, 3), (5, 6)

\section*{Exercise 2.3}
1, 2, 3

\section*{Exercise 3.1}
\begin{tikzpicture}
\node (A) {1};
\node (B) [below of = A]{2};
\node (C) [below of = B]{3};
\node (D) [below of = C]{4};
\node (E) [below of = D]{5};
\node (F) [below of = E]{6};
\node (G) [below right of = F]{7};
\node (I) [below left of = G]{9};
\node (K) [left of = E]{11};

\draw[->] (A) -- (B);
\draw[->] (B) -- (C);
\draw[->] (C) -- (D);
\draw[->] (E) -- (D);
\draw[->] (E) -- (F);
\draw[->] (F) -- (G);
\draw[->] (F) -- (I);
\draw[->] (G) .. controls +(right:25pt) and +(right:25pt) .. (E);
\draw[->] (I) .. controls +(right:55pt) and +(right:55pt) .. (E);
\draw[->] (D.west) .. controls +(left:15pt) and +(up:15pt) .. (K.north);

\end{tikzpicture}

\section*{Exercise 3.2}
(1, 2, 3)

\section*{Exercise 3.3}
1, 2, 3


\begin{tabular}{|c||c|c|c|}
\hline
\rot{45}{\textbf{a\^{}b}} & \textbf{num} & \textbf{bool} & \textbf{str} \\\hline
\hline
\textbf{num}   & num & \textit{error} & \textit{error} \\\hline
\textbf{bool}   & \textit{error} & \textit{error} & \textit{error} \\\hline
\textbf{str}   & str & \textit{error} & \textit{error} \\\hline
\end{tabular}\\[5pt]

\noindent
\begin{tabular}{|c||c|c|c|}
\hline
\rot{45}{\textbf{a+b}}   & \textbf{num} & \textbf{bool} & \textbf{str} \\\hline
\hline
\textbf{num}   & num & \textit{error} & \textit{error} \\\hline
\textbf{bool}   & \textit{error} & bool & \textit{error} \\\hline
\textbf{str}   & \textit{error} & \textit{error} & str \\\hline
\end{tabular}\\[5pt]

\noindent
\begin{tabular}{|c||c|c|c|}
\hline
\rot{45}{\textbf{a=b}}   & \textbf{num} & \textbf{bool} & \textbf{str} \\\hline
\hline
\textbf{num}   & bool & \textit{error} & \textit{error} \\\hline
\textbf{bool}   & \textit{error} & bool & \textit{error} \\\hline
\textbf{str}   & \textit{error} & \textit{error} & bool \\\hline
\end{tabular} \\

\section*{Exercise 3.2}
\noindent
\begin{tabular}{|rcl|l|}
\hline
&& \textbf{Production} & \textbf{Attribution rules} \\\hline
$T_0$ & $\rightarrow$ & $T_1 ~^\wedge ~T_2$ & $T_0$.type $\leftarrow$ $F_{^\wedge}$($T_1$.type, $T_2$.type) \\
& $|$ & $T_1 + T_2$ & $T_0$.type $\leftarrow$ $F_+$($T_1$.type, $T_2$.type) \\
& $|$ & $T_1 = T_2$ & $T_0$.type $\leftarrow$ $F_=$($T_1$.type, $T_2$.type) \\
& $|$ & ($T_1$) & $T_0$.type $\leftarrow$ $T_1$.type \\
$T$ & $\rightarrow$ & Num & $T$.type $\leftarrow$ Num.type \\
& $|$ & Bool & $T$.type $\leftarrow$ Bool.type \\
& $|$ & Str & $T$.type $\leftarrow$ Str.type \\
\hline
\end{tabular}

\section*{Excercise 3.3}

The attributes defined above are synthesized, as a function needs to be called to find out the correct type for the binary expressions.


\section*{Exercise 4.2}
The attribute variant requires less code, and combines language definition and language parsing in one file. The listener variant is however much more flexible, being able to parse both bottom-up and top-down.

\section*{Exercise 4.3}
It break on TIMES and PLUS, something about being mutually left-recursive

Order of before statements does not match the order the after statements (pre-order vs. post-order tree traversal)

\section*{Excercise 4.4}
It provides a tool to get information from both parents and children as well as itself, giving you the option to both inherit and synthesize.

\section*{Exercise 8}
TABLEBEGIN \\
TABLEEND \\
ROWEND \\
COLSEP \\
ENTRY \\
COMMENT $\rightarrow$ skip

\section*{Exercise 9}
The method syntaxError of BaseErrorListener has 6 parameters:\\

\begin{tabular}{|l|p{10cm}|}\hline
Recognizer$<$?, ?$>$ recognizer
& The recognizer which recognized the error. \\\hline

Object offendingSymbol
& The symbol where the error occurred. \\\hline

int line
& The line where the error occurred. \\\hline

int charPositionInLine
& The char position in the line where the error occurred. \\\hline

String msg
& The error message. \\\hline

RecognitionException e
& Extension of RuntimeException, specified for the recognizer in the first parameter. \\\hline
\end{tabular} \\

\end{document}
